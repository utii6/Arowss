<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Arrows Clone - Telegram Mini App</title>
    <style>
        body { margin: 0; background-color: #343441; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        #level-text { font-size: 24px; margin-bottom: 20px; color: #a4a4b5; }
        canvas { background-color: #343441; touch-action: none; border-radius: 10px; }
        .win-msg { position: absolute; font-size: 32px; font-weight: bold; display: none; }
    </style>
</head>
<body>
    <div id="level-text">Level 1</div>
    <canvas id="gameCanvas"></canvas>
    <div id="winMsg" class="win-msg">Ø±Ø§Ø¦Ø¹! ðŸŽ‰</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const winMsg = document.getElementById('winMsg');

        // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ© (Grid)
        const gridSize = 60;
        const rows = 6;
        const cols = 5;
        canvas.width = cols * gridSize;
        canvas.height = rows * gridSize;

        // ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª
        const DIRS = {
            'UP': { dx: 0, dy: -1, angle: -Math.PI/2 },
            'DOWN': { dx: 0, dy: 1, angle: Math.PI/2 },
            'LEFT': { dx: -1, dy: 0, angle: Math.PI },
            'RIGHT': { dx: 1, dy: 0, angle: 0 }
        };

        // Ù…ØµÙÙˆÙØ© Ø§Ù„Ø£Ø³Ù‡Ù… (Level Data)
        let arrows = [
            { x: 2, y: 1, dir: DIRS.RIGHT, status: 'static' },
            { x: 4, y: 1, dir: DIRS.DOWN, status: 'static' },
            { x: 4, y: 4, dir: DIRS.LEFT, status: 'static' },
            { x: 2, y: 4, dir: DIRS.UP, status: 'static' },
            { x: 2, y: 2, dir: DIRS.LEFT, status: 'static' }
        ];

        function drawArrow(arrow) {
            const px = arrow.x * gridSize + gridSize/2;
            const py = arrow.y * gridSize + gridSize/2;
            
            ctx.save();
            ctx.translate(px, py);
            ctx.rotate(arrow.dir.angle);
            
            // Ø±Ø³Ù… Ø§Ù„Ø³Ù‡Ù…
            ctx.beginPath();
            ctx.strokeStyle = arrow.status === 'moving' ? '#ffffff' : '#6e6e7d';
            ctx.lineWidth = 4;
            ctx.lineJoin = 'round';
            ctx.moveTo(-15, 0);
            ctx.lineTo(15, 0);
            ctx.lineTo(5, -10);
            ctx.moveTo(15, 0);
            ctx.lineTo(5, 10);
            ctx.stroke();
            
            ctx.restore();
        }

        function isPathClear(target) {
            for (let a of arrows) {
                if (a === target || a.status === 'removed') continue;
                
                // Ù…Ù†Ø·Ù‚ Ø§Ù„ØªØµØ§Ø¯Ù…: Ù‡Ù„ ÙŠÙˆØ¬Ø¯ Ø³Ù‡Ù… Ø¢Ø®Ø± ÙÙŠ Ù…Ø³Ø§Ø± Ø§Ù„Ø³Ù‡Ù… Ø§Ù„Ø­Ø§Ù„ÙŠØŸ
                if (target.dir.dx !== 0) { // Ø­Ø±ÙƒØ© Ø£ÙÙ‚ÙŠØ©
                    if (a.y === target.y && (target.dir.dx > 0 ? a.x > target.x : a.x < target.x)) return false;
                } else { // Ø­Ø±ÙƒØ© Ø±Ø£Ø³ÙŠØ©
                    if (a.x === target.x && (target.dir.dy > 0 ? a.y > target.y : a.y < target.y)) return false;
                }
            }
            return true;
        }

        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            let allRemoved = true;
            arrows.forEach(a => {
                if (a.status === 'moving') {
                    a.x += a.dir.dx * 0.2;
                    a.y += a.dir.dy * 0.2;
                    // Ø¥Ø°Ø§ Ø®Ø±Ø¬ Ø§Ù„Ø³Ù‡Ù… Ø¹Ù† Ø§Ù„Ø´Ø§Ø´Ø©
                    if (a.x < -1 || a.x > cols || a.y < -1 || a.y > rows) a.status = 'removed';
                }
                if (a.status !== 'removed') {
                    drawArrow(a);
                    allRemoved = false;
                }
            });

            if (allRemoved) winMsg.style.display = 'block';
            requestAnimationFrame(update);
        }

        canvas.addEventListener('touchstart', (e) => {
            const rect = canvas.getBoundingClientRect();
            const touchX = (e.touches[0].clientX - rect.left) / gridSize;
            const touchY = (e.touches[0].clientY - rect.top) / gridSize;

            arrows.forEach(a => {
                if (a.status === 'static' && Math.hypot(a.x + 0.5 - touchX, a.y + 0.5 - touchY) < 0.5) {
                    if (isPathClear(a)) {
                        a.status = 'moving';
                    } else {
                        // ØªØ£Ø«ÙŠØ± Ø¨ØµØ±ÙŠ Ø¨Ø³ÙŠØ· Ø¹Ù†Ø¯ Ø§Ù„Ø®Ø·Ø£ (Ù‡Ø² Ø§Ù„Ø³Ù‡Ù… Ù…Ø«Ù„Ø§Ù‹)
                        console.log("Ø§Ù„Ù…Ø³Ø§Ø± Ù…ØºÙ„Ù‚!");
                    }
                }
            });
        });

        update();
    </script>
</body>
</html>
